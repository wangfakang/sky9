{"name":"Sky9","tagline":"balancer_by_lua  analysis","body":"`balancer_by_lua的开发`\r\n\r\n该模块基本思想：  \r\n　　就是完全绕过了之前的upstream，自己设置相应的回调  \r\n\r\n\r\n该模块的运用：      \r\n　　动态管理nginx的upstream方案如下：       \r\n　　这里我感觉玩法还是蛮多的，其一就是把相应的后端server信息进行存放在第三方库中[redis等],然后相应\r\n的信息加载到share memory进行缓存，然后可以在location中为每一个请求进行设置当前请求的server信息\r\n［可以记录在ngx.ctx中］，然后在balancer_by_lua中进行读取ngx.ctx进行调用set_current_peer进行相\r\n应的后端server的路由．    \r\n\r\n\r\n\r\n下面就相应的源码进行简单解析下：      \r\n\r\n\r\n这是其balancer的路由数据结构：   \r\n```c\r\n+typedef struct {\r\n+    /* the round robin data must be first */\r\n+    ngx_http_upstream_rr_peer_data_t    rrp;//复用了round_robin的数据结构，当后面没有设置sockaddr的时候就会调用round_robin进行路由\r\n+\r\n+    ngx_http_lua_srv_conf_t            *conf;\r\n+    ngx_http_request_t                 *request;\r\n+\r\n+    ngx_event_get_peer_pt               get_rr_peer;\r\n+\r\n+    ngx_uint_t                          more_tries;\r\n+    ngx_uint_t                          total_tries;//当前总的重试次数\r\n+\r\n+    struct sockaddr                    *sockaddr;\r\n+    socklen_t                           socklen;\r\n+\r\n+    ngx_str_t                           host;\r\n+    in_port_t                           port;\r\n+\r\n+    int                                 last_peer_state;\r\n+} ngx_http_lua_balancer_peer_data_t;\r\n+\r\n```\r\n\r\n```c\r\nbalancer_by_lua的初始化函数．在配置文件解析的时候执行\r\nchar *\r\n+ngx_http_lua_balancer_by_lua(ngx_conf_t *cf, ngx_command_t *cmd,\r\n+    void *conf)\r\n+{\r\n+ ．．．．．．．．．\r\n+    value = cf->args->elts;\r\n+\r\n+    lscf->balancer.handler = (ngx_http_lua_srv_conf_handler_pt) cmd->post;\r\n+\r\n+    if (cmd->post == ngx_http_lua_balancer_handler_file) {\r\n+        /* Lua code in an external file */\r\n+\r\n+        name = ngx_http_lua_rebase_path(cf->pool, value[1].data,\r\n+                                        value[1].len);\r\n+        if (name == NULL) {\r\n+            return NGX_CONF_ERROR;\r\n+        }\r\n+\r\n+        lscf->balancer.src.data = name;\r\n+        lscf->balancer.src.len = ngx_strlen(name);\r\n+\r\n+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_FILE_KEY_LEN + 1);\r\n+        if (p == NULL) {\r\n+            return NGX_CONF_ERROR;\r\n+        }\r\n+\r\n+        lscf->balancer.src_key = p;\r\n+\r\n+        p = ngx_copy(p, NGX_HTTP_LUA_FILE_TAG, NGX_HTTP_LUA_FILE_TAG_LEN);\r\n+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);\r\n+        *p = '\\0';\r\n+\r\n+    } else {\r\n+        /* inlined Lua code */\r\n+\r\n+        lscf->balancer.src = value[1];\r\n+\r\n+        p = ngx_palloc(cf->pool, NGX_HTTP_LUA_INLINE_KEY_LEN + 1);\r\n+        if (p == NULL) {\r\n+            return NGX_CONF_ERROR;\r\n+        }\r\n+\r\n+        lscf->balancer.src_key = p;\r\n+\r\n+        p = ngx_copy(p, NGX_HTTP_LUA_INLINE_TAG, NGX_HTTP_LUA_INLINE_TAG_LEN);\r\n+        p = ngx_http_lua_digest_hex(p, value[1].data, value[1].len);\r\n+        *p = '\\0';\r\n+    }\r\n+\r\n+    uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);\r\n+\r\n+    if (uscf->peer.init_upstream) {\r\n+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\r\n+                           \"load balancing method redefined\");\r\n+    }\r\n+　　　　//主要就是这个回调的设置　这个主要就是在init_upstream的时候进行判断　然后进行执行［解析upstream模块的时候］\r\n+    uscf->peer.init_upstream = ngx_http_lua_balancer_init;\r\n+\r\n+    uscf->flags = NGX_HTTP_UPSTREAM_CREATE\r\n+                  |NGX_HTTP_UPSTREAM_WEIGHT\r\n+                  |NGX_HTTP_UPSTREAM_MAX_FAILS\r\n+                  |NGX_HTTP_UPSTREAM_FAIL_TIMEOUT\r\n+                  |NGX_HTTP_UPSTREAM_DOWN;\r\n+\r\n+    return NGX_CONF_OK;\r\n+}\r\n+\r\n```\r\n\r\n在配置文件解析饿时候执行，也就是上面设置饿回调［upstream解析的时候］\r\n```c\r\nstatic ngx_int_t\r\n+ngx_http_lua_balancer_init(ngx_conf_t *cf,\r\n+    ngx_http_upstream_srv_conf_t *us)\r\n+{\r\n+    if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {\r\n+        return NGX_ERROR;\r\n+    }\r\n+\r\n+    /* this callback is called upon individual requests */\r\n+    us->peer.init = ngx_http_lua_balancer_init_peer;//每一个请求的初始化函数\r\n+\r\n+    return NGX_OK;\r\n+}\r\n```\r\n\r\n\r\n每一个请求都会执行的，主要就是设置相应的回调    \r\n```c  \r\n+static ngx_int_t\r\n+ngx_http_lua_balancer_init_peer(ngx_http_request_t *r,\r\n+    ngx_http_upstream_srv_conf_t *us)\r\n+{\r\n+    ngx_http_lua_srv_conf_t            *bcf;\r\n+    ngx_http_lua_balancer_peer_data_t  *bp;\r\n+　　　　//给自己的轮子造空间\r\n+    bp = ngx_pcalloc(r->pool, sizeof(ngx_http_lua_balancer_peer_data_t));\r\n+    if (bp == NULL) {\r\n+        return NGX_ERROR;\r\n+    }\r\n+\r\n+    r->upstream->peer.data = &bp->rrp;\r\n+\r\n+    if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {//默认的round_robin的初始化\r\n+        return NGX_ERROR;\r\n+    }\r\n+\r\n+    r->upstream->peer.get = ngx_http_lua_balancer_get_peer;//设置每一个请求获取后端server的方法\r\n+    r->upstream->peer.free = ngx_http_lua_balancer_free_peer;//设置每一个请求获取后端server执行玩的方法\r\n+\r\n+    bcf = ngx_http_conf_upstream_srv_conf(us, ngx_http_lua_module);\r\n+\r\n+    bp->conf = bcf;\r\n+    bp->get_rr_peer = ngx_http_upstream_get_round_robin_peer;/默认的round_robin方式获取\r\n+    bp->request = r;\r\n+\r\n+    return NGX_OK;\r\n+}\r\n+\r\n```\r\n\r\n这个函数就是每个请求的回调钩子－－－如何获取后端的server   \r\n\r\n```c\r\nstatic ngx_int_t\r\n+ngx_http_lua_balancer_get_peer(ngx_peer_connection_t *pc, void *data)\r\n+{\r\n+    lua_State                          *L;\r\n+    ngx_int_t                           rc;\r\n+    ngx_http_request_t                 *r;\r\n+    ngx_http_lua_ctx_t                 *ctx;\r\n+    ngx_http_lua_srv_conf_t            *lscf;\r\n+    ngx_http_lua_balancer_peer_data_t  *bp = data;\r\n+\r\n+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc->log, 0,\r\n+                   \"lua balancer peer, try: %ui\", pc->tries);\r\n+\r\n+    lscf = bp->conf;\r\n+\r\n+    r = bp->request;\r\n+\r\n+    ngx_http_lua_assert(lscf->balancer.handler && r);\r\n+\r\n+    L = ngx_http_lua_get_lua_vm(r, NULL);\r\n+\r\n+    bp->sockaddr = NULL;\r\n+    bp->socklen = 0;\r\n+    bp->more_tries = 0;\r\n+    bp->total_tries++;\r\n+\r\n+    rc = lscf->balancer.handler(r, lscf, L);\r\n+\r\n+    if (rc == NGX_ERROR) {\r\n+        return NGX_ERROR;\r\n+    }\r\n+\r\n+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);\r\n+\r\n+    if (ctx->exited && ctx->exit_code != NGX_OK) {\r\n+        rc = ctx->exit_code;\r\n+        if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {\r\n+            return rc;\r\n+        }\r\n+\r\n+        if (rc > NGX_OK) {\r\n+            return NGX_ERROR;\r\n+        }\r\n+    }\r\n+\r\n+    if (bp->sockaddr && bp->socklen) { //如果设置了［执行了set_current_peer］就会直接选择\r\n+        pc->sockaddr = bp->sockaddr;\r\n+        pc->socklen = bp->socklen;\r\n+        pc->name = &bp->host;\r\n+        bp->rrp.peers->single = 0;\r\n+\r\n+        if (bp->more_tries) {\r\n+            r->upstream->peer.tries += bp->more_tries;\r\n+        }\r\n+\r\n+        dd(\"tries: %d\", (int) r->upstream->peer.tries);\r\n+\r\n+        return NGX_OK;\r\n+    }\r\n+\r\n+    return bp->get_rr_peer(pc, &bp->rrp);//没有设置的话就采用round_robin的方式来获取\r\n+}\r\n+\r\n```\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"balancer_by_lua  analysis","note":"Don't delete this file! It's used internally to help with page regeneration."}